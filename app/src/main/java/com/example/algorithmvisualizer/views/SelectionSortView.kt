package com.example.algorithmvisualizer.views

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import com.example.algorithmvisualizer.R
import com.example.algorithmvisualizer.algorithm.SelectionSortStep
import com.example.algorithmvisualizer.algorithm.generateSelectionSortSteps
import com.example.algorithmvisualizer.algorithm.resetArray
import com.example.algorithmvisualizer.components.ExplanationCard
import com.example.algorithmvisualizer.components.PlaybackControls
import com.example.algorithmvisualizer.components.TimelineSlider
import com.example.algorithmvisualizer.ui.theme.DarkGray
import com.example.algorithmvisualizer.ui.theme.LightGray
import com.example.algorithmvisualizer.ui.theme.Primary
import com.example.algorithmvisualizer.ui.theme.Secondary
import kotlinx.coroutines.delay

/**
 * SelectionSortView visualizes the Selection Sort algorithm with:
 * - A title-like explanation (inside a scrollable container) referencing the selection sort code.
 * - A graphical representation where each bar displays its numerical value.
 * - Interactive controls (Play/Pause, Next, Previous, Reset), arranged like a music player,
 *   using the same colors, font, and style as BubbleSortView.
 */
@Composable
fun SelectionSortView() {
    // We'll use 10 columns for the array.
    val arraySize = 10

    // State holding the array values.
    val arrayState = remember { mutableStateListOf<Int>() }
    // List of SelectionSortStep generated by the algorithm.
    val steps = remember { mutableStateListOf<SelectionSortStep>() }
    // Current step index in the animation timeline.
    var currentStepIndex by remember { mutableStateOf(0) }
    // Flag to indicate if the animation is playing.
    var isPlaying by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()

    // Initialize the array and generate the steps when the composable first loads.
    LaunchedEffect(Unit) {
        resetArray(arrayState, arraySize, maxNumber = 500)
        steps.clear()
        steps.addAll(generateSelectionSortSteps(arrayState))
        currentStepIndex = 0
    }

    // Auto-advance the animation if Play mode is enabled.
    LaunchedEffect(isPlaying, currentStepIndex) {
        if (isPlaying) {
            if (currentStepIndex < steps.lastIndex) {
                delay(200L)
                currentStepIndex++
            } else {
                isPlaying = false
            }
        }
    }

    // Get the current selection sort step (if available).
    val currentStep = steps.getOrNull(currentStepIndex)

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Reusable ExplanationCard with the selection sort explanation text.
        ExplanationCard(
            explanationText = stringResource(id = R.string.explanation_text_selection),
            cardHeight = 350.dp
        )

        Spacer(modifier = Modifier.height(16.dp))

        // Visualization area and controls.
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
        ) {
            // Canvas area for drawing the array bars.
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .weight(1f)
            ) {
                currentStep?.let { step ->
                    Canvas(
                        modifier = Modifier
                            .fillMaxSize()
                            .border(width = 2.dp, color = LightGray)
                    ) {
                        // Calculate slot and bar widths.
                        val slotWidth = size.width / step.array.size
                        val barWidth = slotWidth * 0.8f
                        val horizontalPadding = (slotWidth - barWidth) / 2f

                        // Prepare paint for drawing numbers.
                        val textPaint = android.graphics.Paint().apply {
                            color = DarkGray.toArgb()
                            textSize = 30f
                            textAlign = android.graphics.Paint.Align.CENTER
                        }

                        // Draw each bar with highlighted compared indices.
                        step.array.forEachIndexed { index, value ->
                            val barColor = if (
                                index == step.comparedIndices.first ||
                                index == step.comparedIndices.second
                            ) Secondary else Primary

                            val leftX = index * slotWidth + horizontalPadding
                            val topY = size.height - value

                            drawRect(
                                color = barColor,
                                topLeft = Offset(leftX, topY),
                                size = Size(width = barWidth, height = value.toFloat())
                            )

                            drawIntoCanvas { canvas ->
                                canvas.nativeCanvas.drawText(
                                    value.toString(),
                                    leftX + (barWidth / 2f),
                                    topY - 10,
                                    textPaint
                                )
                            }
                        }
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Render the TimelineSlider if steps are available.
            if (steps.isNotEmpty()) {
                TimelineSlider(
                    currentStep = currentStepIndex.toFloat(),
                    maxStep = (steps.size - 1).toFloat(),
                    onStepChange = { newValue ->
                        currentStepIndex = newValue.toInt().coerceIn(0, steps.lastIndex)
                        isPlaying = false
                    }
                )
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Reusable PlaybackControls for play/pause, previous, next, and reset actions.
            if (steps.isNotEmpty()) {
                PlaybackControls(
                    isPlaying = isPlaying,
                    onPlayPauseToggle = { isPlaying = !isPlaying },
                    onPrevious = {
                        currentStepIndex = (currentStepIndex - 1).coerceAtLeast(0)
                        isPlaying = false
                    },
                    onNext = {
                        currentStepIndex = (currentStepIndex + 1).coerceAtMost(steps.lastIndex)
                        isPlaying = false
                    },
                    onReset = {
                        isPlaying = false
                        resetArray(arrayState, arraySize, maxNumber = 500)
                        steps.clear()
                        steps.addAll(generateSelectionSortSteps(arrayState))
                        currentStepIndex = 0
                    }
                )
            }
        }
    }
}