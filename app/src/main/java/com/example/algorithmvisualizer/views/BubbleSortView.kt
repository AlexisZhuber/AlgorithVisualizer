package com.example.algorithmvisualizer.views

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Slider
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.example.algorithmvisualizer.R
import com.example.algorithmvisualizer.algorithm.BubbleSortStep
import com.example.algorithmvisualizer.algorithm.generateBubbleSortSteps
import com.example.algorithmvisualizer.algorithm.resetArray
import com.example.algorithmvisualizer.ui.theme.BackgroundCard
import com.example.algorithmvisualizer.ui.theme.DarkGray
import com.example.algorithmvisualizer.ui.theme.LightGray
import com.example.algorithmvisualizer.ui.theme.Primary
import com.example.algorithmvisualizer.ui.theme.Secondary
import com.example.algorithmvisualizer.ui.theme.TextColor
import kotlinx.coroutines.delay

/**
 * BubbleSortView is a composable function that displays the visualization
 * of the Bubble Sort algorithm.
 *
 * This view consists of:
 * - An explanation card that describes the Bubble Sort algorithm.
 * - A canvas area where the array is drawn as vertical bars.
 * - A timeline slider to control the progress of the animation.
 * - Control buttons (play/pause, previous, next, reset) to navigate through the steps.
 */
@Composable
fun BubbleSortView() {
    // Define the size of the array; we want 10 columns.
    val arraySize = 10

    // State holding the array of integers to be sorted.
    val arrayState = remember { mutableStateListOf<Int>() }
    // List of steps generated by the Bubble Sort algorithm.
    val steps = remember { mutableStateListOf<BubbleSortStep>() }
    // Current step index in the animation timeline.
    var currentStepIndex by remember { mutableStateOf(0) }
    // Flag indicating if the animation is playing automatically.
    var isPlaying by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()

    // When the composable loads, initialize the array and generate sorting steps.
    LaunchedEffect(Unit) {
        // Reset the array with random numbers within [0, 500].
        resetArray(arrayState, arraySize, maxNumber = 500)
        // Clear any previous steps and generate new Bubble Sort steps.
        steps.clear()
        steps.addAll(generateBubbleSortSteps(arrayState))
        // Start at the beginning of the timeline.
        currentStepIndex = 0
    }

    // Automatically advance the animation if play mode is enabled.
    LaunchedEffect(isPlaying, currentStepIndex) {
        if (isPlaying) {
            if (currentStepIndex < steps.lastIndex) {
                delay(200L) // Delay between each step.
                currentStepIndex++
            } else {
                // Stop the animation when the final step is reached.
                isPlaying = false
            }
        }
    }

    // Get the current step of the algorithm, if available.
    val currentStep = steps.getOrNull(currentStepIndex)

    // Main layout container.
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Explanation card displaying the Bubble Sort algorithm explanation.
        ElevatedCard(
            modifier = Modifier
                .fillMaxWidth()
                .height(350.dp),
            shape = RoundedCornerShape(12.dp),
            colors = CardDefaults.cardColors(
                containerColor = BackgroundCard
            )
        ) {
            // Scrollable column inside the card for the explanation text.
            Column(
                modifier = Modifier
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp)
            ) {
                Text(
                    text = stringResource(id = R.string.explanation_text_bubble),
                    color = TextColor,
                    // Use a larger font size with increased line height for readability.
                    style = MaterialTheme.typography.bodyLarge.copy(lineHeight = 24.sp),
                    textAlign = TextAlign.Justify
                )
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Container for the visualization area and control buttons.
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
        ) {
            // Canvas area where the array bars are drawn.
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .weight(1f)
            ) {
                currentStep?.let { step ->
                    Canvas(
                        modifier = Modifier
                            .fillMaxWidth()
                            .fillMaxHeight()
                            .border(width = 2.dp, color = LightGray)
                    ) {
                        // Calculate the width of each slot (column) based on the canvas width.
                        val slotWidth = size.width / step.array.size
                        // Bar width is set to 80% of the slot width.
                        val barWidth = slotWidth * 0.8f
                        // Calculate horizontal padding to center the bar in its slot.
                        val horizontalPadding = (slotWidth - barWidth) / 2f

                        // Prepare a Paint object to draw the number on the bars.
                        val textPaint = android.graphics.Paint().apply {
                            color = DarkGray.toArgb()
                            textSize = 30f
                            textAlign = android.graphics.Paint.Align.CENTER
                        }

                        // Draw each bar and its corresponding number.
                        step.array.forEachIndexed { index, value ->
                            // Determine the color: if the index is one of the two being compared, use Secondary; otherwise, Primary.
                            val barColor = if (
                                index == step.comparedIndices.first ||
                                index == step.comparedIndices.second
                            ) {
                                Secondary
                            } else {
                                Primary
                            }

                            // Calculate the left x-coordinate of the bar.
                            val leftX = index * slotWidth + horizontalPadding
                            // The top y-coordinate is determined by the bar's height.
                            val topY = size.height - value

                            // Draw the bar as a rectangle.
                            drawRect(
                                color = barColor,
                                topLeft = Offset(x = leftX, y = topY),
                                size = Size(width = barWidth, height = value.toFloat())
                            )

                            // Draw the numerical value above the bar.
                            drawIntoCanvas { canvas ->
                                canvas.nativeCanvas.drawText(
                                    value.toString(),
                                    leftX + (barWidth / 2f),
                                    topY - 10,
                                    textPaint
                                )
                            }
                        }
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Slider for controlling the timeline of the sorting animation.
            if (steps.isNotEmpty()) {
                Slider(
                    value = currentStepIndex.toFloat(),
                    onValueChange = { newValue ->
                        currentStepIndex = newValue.toInt()
                        // Pause the automatic animation when the user interacts with the slider.
                        isPlaying = false
                    },
                    valueRange = 0f..(steps.size - 1).toFloat(),
                    colors = SliderDefaults.colors(
                        thumbColor = Primary,
                        activeTrackColor = Primary,
                        inactiveTrackColor = LightGray
                    ),
                    modifier = Modifier.fillMaxWidth()
                )
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Control buttons arranged like media player controls.
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                // Play/Pause toggle button.
                IconButton(onClick = { isPlaying = !isPlaying }) {
                    Icon(
                        painter = painterResource(
                            id = if (isPlaying) R.drawable.pause else R.drawable.play
                        ),
                        contentDescription = if (isPlaying)
                            stringResource(id = R.string.pause)
                        else
                            stringResource(id = R.string.play),
                        tint = Primary
                    )
                }
                // Skip to previous step button.
                IconButton(onClick = {
                    currentStepIndex = (currentStepIndex - 1).coerceAtLeast(0)
                    isPlaying = false
                }) {
                    Icon(
                        painter = painterResource(id = R.drawable.skip_previous),
                        contentDescription = stringResource(id = R.string.previous),
                        tint = Primary
                    )
                }
                // Skip to next step button.
                IconButton(onClick = {
                    currentStepIndex = (currentStepIndex + 1).coerceAtMost(steps.lastIndex)
                    isPlaying = false
                }) {
                    Icon(
                        painter = painterResource(id = R.drawable.skip_next),
                        contentDescription = stringResource(id = R.string.next),
                        tint = Primary
                    )
                }
                // Reset button to restart the sorting visualization.
                IconButton(onClick = {
                    isPlaying = false
                    // Reset the array with new random values.
                    resetArray(arrayState, arraySize, maxNumber = 500)
                    // Regenerate the Bubble Sort steps.
                    steps.clear()
                    steps.addAll(generateBubbleSortSteps(arrayState))
                    // Reset the timeline to the beginning.
                    currentStepIndex = 0
                }) {
                    Icon(
                        painter = painterResource(id = R.drawable.refresh),
                        contentDescription = stringResource(id = R.string.reset),
                        tint = Primary
                    )
                }
            }
        }
    }
}
