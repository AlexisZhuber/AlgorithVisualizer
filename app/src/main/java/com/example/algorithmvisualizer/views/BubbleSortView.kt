package com.example.algorithmvisualizer.views

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Slider
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.example.algorithmvisualizer.R
import com.example.algorithmvisualizer.algorithm.BubbleSortStep
import com.example.algorithmvisualizer.algorithm.generateBubbleSortSteps
import com.example.algorithmvisualizer.algorithm.resetArray
import com.example.algorithmvisualizer.ui.theme.BackgroundCard
import com.example.algorithmvisualizer.ui.theme.DarkGray
import com.example.algorithmvisualizer.ui.theme.LightGray
import com.example.algorithmvisualizer.ui.theme.Primary
import com.example.algorithmvisualizer.ui.theme.Secondary
import com.example.algorithmvisualizer.ui.theme.TextColor
import kotlinx.coroutines.delay

@Composable
fun BubbleSortView() {
    // We only want 10 columns.
    val arraySize = 10

    // State containing the values of the array.
    val arrayState = remember { mutableStateListOf<Int>() }
    // List of steps generated by the Bubble Sort algorithm.
    val steps = remember { mutableStateListOf<BubbleSortStep>() }
    // Current step index in the timeline.
    var currentStepIndex by remember { mutableStateOf(0) }
    // Flag indicating if the animation is playing automatically.
    var isPlaying by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()

    // Initialize the array and generate the steps when the composable loads.
    LaunchedEffect(Unit) {
        // We'll reset the array with numbers in [0..500].
        resetArray(arrayState, arraySize, maxNumber = 500)
        steps.clear()
        steps.addAll(generateBubbleSortSteps(arrayState))
        currentStepIndex = 0
    }

    // Advance the step index if Play mode is enabled.
    LaunchedEffect(isPlaying, currentStepIndex) {
        if (isPlaying) {
            if (currentStepIndex < steps.lastIndex) {
                delay(300L)
                currentStepIndex++
            } else {
                isPlaying = false
            }
        }
    }

    // Get the current step (if available).
    val currentStep = steps.getOrNull(currentStepIndex)

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // A fixed Box with a border. Inside it, we place a scrollable Column.
        // Explanation card
        ElevatedCard(
            modifier = Modifier
                .fillMaxWidth()
                .height(350.dp),
            shape = RoundedCornerShape(12.dp),
            colors = CardDefaults.cardColors(
                containerColor = BackgroundCard
            )
        ) {
            // Scrollable column for BFS explanation
            Column(
                modifier = Modifier
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp)
            ) {
                Text(
                    text = stringResource(id = R.string.explanation_text_bubble),
                    color = TextColor,
                    // Slightly larger text, some line height for readability
                    style = MaterialTheme.typography.bodyLarge.copy(
                        lineHeight = 24.sp
                    ),
                    textAlign = TextAlign.Justify
                )
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Visualization area and controls.
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
        ) {
            // Canvas area where the array bars are drawn.
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .weight(1f)
            ) {
                currentStep?.let { step ->
                    Canvas(
                        modifier = Modifier
                            .fillMaxWidth()
                            .fillMaxHeight()
                            .border(width = 2.dp, color = LightGray)
                    ) {
                        // Calculate slot width for each column and bar width for spacing.
                        val slotWidth = size.width / step.array.size
                        val barWidth = slotWidth * 0.8f
                        val horizontalPadding = (slotWidth - barWidth) / 2f

                        // Prepare the paint for drawing numbers.
                        val textPaint = android.graphics.Paint().apply {
                            color = DarkGray.toArgb()
                            textSize = 30f
                            textAlign = android.graphics.Paint.Align.CENTER
                        }

                        step.array.forEachIndexed { index, value ->
                            val barColor = if (
                                index == step.comparedIndices.first ||
                                index == step.comparedIndices.second
                            ) {
                                Secondary
                            } else {
                                Primary
                            }

                            val leftX = index * slotWidth + horizontalPadding
                            val topY = size.height - value

                            // Draw the bar.
                            drawRect(
                                color = barColor,
                                topLeft = Offset(x = leftX, y = topY),
                                size = Size(width = barWidth, height = value.toFloat())
                            )

                            // Draw the numerical value on the bar.
                            drawIntoCanvas { canvas ->
                                canvas.nativeCanvas.drawText(
                                    value.toString(),
                                    leftX + (barWidth / 2f),
                                    topY - 10,
                                    textPaint
                                )
                            }
                        }
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Timeline slider with a darker "passed" portion.
            if (steps.isNotEmpty()) {
                Slider(
                    value = currentStepIndex.toFloat(),
                    onValueChange = { newValue ->
                        currentStepIndex = newValue.toInt()
                        isPlaying = false
                    },
                    valueRange = 0f..(steps.size - 1).toFloat(),
                    colors = SliderDefaults.colors(
                        thumbColor = Primary,
                        activeTrackColor = Primary,
                        inactiveTrackColor = LightGray
                    ),
                    modifier = Modifier.fillMaxWidth()
                )
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Icon buttons arranged like a music player (using custom drawables).
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                // Play / Pause toggle
                IconButton(onClick = { isPlaying = !isPlaying }) {
                    Icon(
                        painter = painterResource(
                            id = if (isPlaying) R.drawable.pause else R.drawable.play
                        ),
                        contentDescription = if (isPlaying) stringResource(id = R.string.pause) else stringResource(id = R.string.play),
                        tint = Primary
                    )
                }
                // Skip Previous
                IconButton(onClick = {
                    currentStepIndex = (currentStepIndex - 1).coerceAtLeast(0)
                    isPlaying = false
                }) {
                    Icon(
                        painter = painterResource(id = R.drawable.skip_previous),
                        contentDescription = stringResource(id = R.string.previous),
                        tint = Primary
                    )
                }
                // Skip Next
                IconButton(onClick = {
                    currentStepIndex = (currentStepIndex + 1).coerceAtMost(steps.lastIndex)
                    isPlaying = false
                }) {
                    Icon(
                        painter = painterResource(id = R.drawable.skip_next),
                        contentDescription = stringResource(id = R.string.next),
                        tint = Primary
                    )
                }
                // Refresh (reset)
                IconButton(onClick = {
                    isPlaying = false
                    resetArray(arrayState, arraySize, maxNumber = 500)
                    steps.clear()
                    steps.addAll(generateBubbleSortSteps(arrayState))
                    currentStepIndex = 0
                }) {
                    Icon(
                        painter = painterResource(id = R.drawable.refresh),
                        contentDescription = stringResource(id = R.string.reset),
                        tint = Primary
                    )
                }
            }
        }
    }
}
