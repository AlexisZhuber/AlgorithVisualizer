package com.example.algorithmvisualizer.views

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Slider
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.unit.dp
import com.example.algorithmvisualizer.R
import com.example.algorithmvisualizer.algorithm.BubbleSortStep
import com.example.algorithmvisualizer.algorithm.generateBubbleSortSteps
import com.example.algorithmvisualizer.algorithm.resetArray
import com.example.algorithmvisualizer.ui.theme.DarkGray
import com.example.algorithmvisualizer.ui.theme.Gray
import com.example.algorithmvisualizer.ui.theme.LightGray
import com.example.algorithmvisualizer.ui.theme.Primary
import com.example.algorithmvisualizer.ui.theme.Secondary
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

/**
 * BubbleSortView visualizes the Bubble Sort algorithm with:
 * - A title and detailed explanation (inside a scrollable container) that includes
 *   a Kotlin code example.
 * - A graphical representation where each bar displays its numerical value.
 * - Interactive controls (Play/Pause, Next, Previous, Reset) arranged like a music player,
 *   using custom icon buttons from the drawable folder.
 */
@Composable
fun BubbleSortView() {
    // Now we only want 10 columns instead of 30.
    val arraySize = 10

    // State containing the values of the array.
    val arrayState = remember { mutableStateListOf<Int>() }
    // List of steps generated by the Bubble Sort algorithm.
    val steps = remember { mutableStateListOf<BubbleSortStep>() }
    // Current step index in the timeline.
    var currentStepIndex by remember { mutableStateOf(0) }
    // Flag indicating if the animation is playing automatically.
    var isPlaying by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()

    // Initialize the array and generate the steps when the composable loads.
    LaunchedEffect(Unit) {
        // We'll reset the array with numbers in [0..100].
        resetArray(arrayState, arraySize, maxNumber = 800)
        steps.clear()
        steps.addAll(generateBubbleSortSteps(arrayState))
        currentStepIndex = 0
    }

    // Effect to advance the step index if Play mode is enabled.
    LaunchedEffect(isPlaying, currentStepIndex) {
        if (isPlaying) {
            if (currentStepIndex < steps.lastIndex) {
                delay(300L)
                currentStepIndex++
            } else {
                isPlaying = false
            }
        }
    }

    // Get the current step (if available).
    val currentStep = steps.getOrNull(currentStepIndex)

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Title using stringResource for internationalization.
        Text(
            text = stringResource(id = R.string.app_name),
            color = Primary
        )
        Spacer(modifier = Modifier.height(8.dp))

        // Scrollable container displaying the extended explanation.
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(350.dp) // Increased height for more content
                .verticalScroll(rememberScrollState())
                .border(width = 1.dp, color = Gray)
                .padding(8.dp)
        ) {
            Text(
                text = stringResource(id = R.string.explanation_text),
                color = DarkGray,
                fontFamily = FontFamily.Monospace
            )
        }
        Spacer(modifier = Modifier.height(16.dp))

        // Visualization area and controls.
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
        ) {
            // Canvas area where the array bars are drawn.
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .weight(1f)
            ) {
                currentStep?.let { step ->
                    Canvas(
                        modifier = Modifier
                            .fillMaxWidth()
                            .fillMaxHeight()
                            .border(width = 2.dp, color = LightGray)
                    ) {
                        // We'll calculate a slotWidth for each column, then
                        // make the bar occupy some percentage of that slot.
                        val slotWidth = size.width / step.array.size
                        val barWidth = slotWidth * 0.8f // 80% of the slot
                        val horizontalPadding = (slotWidth - barWidth) / 2f

                        // Prepare the paint for drawing numbers (using DarkGray for better contrast).
                        val textPaint = android.graphics.Paint().apply {
                            color = DarkGray.toArgb()
                            textSize = 30f // Keep the same text size
                            textAlign = android.graphics.Paint.Align.CENTER
                        }

                        step.array.forEachIndexed { index, value ->
                            // Use 'Secondary' for compared bars and 'Primary' for others.
                            val barColor = if (index == step.comparedIndices.first || index == step.comparedIndices.second) {
                                Secondary
                            } else {
                                Primary
                            }

                            // X position: slotWidth * index + horizontalPadding
                            val leftX = index * slotWidth + horizontalPadding
                            val topY = size.height - value

                            // Draw the bar with a bit of spacing around it.
                            drawRect(
                                color = barColor,
                                topLeft = Offset(x = leftX, y = topY),
                                size = Size(width = barWidth, height = value.toFloat())
                            )

                            // Draw the numerical value on the bar.
                            drawIntoCanvas { canvas ->
                                canvas.nativeCanvas.drawText(
                                    value.toString(),
                                    leftX + (barWidth / 2f),
                                    topY - 10,
                                    textPaint
                                )
                            }
                        }
                    }
                }
            }
            Spacer(modifier = Modifier.height(16.dp))

            // Timeline slider.
            if (steps.isNotEmpty()) {
                Slider(
                    value = currentStepIndex.toFloat(),
                    onValueChange = { newValue ->
                        currentStepIndex = newValue.toInt()
                        isPlaying = false
                    },
                    valueRange = 0f..(steps.size - 1).toFloat(),
                    colors = SliderDefaults.colors(
                        thumbColor = DarkGray,
                        activeTrackColor = LightGray
                    ),
                    modifier = Modifier.fillMaxWidth()
                )
            }
            Spacer(modifier = Modifier.height(16.dp))

            // Icon buttons arranged like a music player (using custom drawables).
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                // Play / Pause toggle
                IconButton(onClick = { isPlaying = !isPlaying }) {
                    Icon(
                        painter = painterResource(
                            id = if (isPlaying) R.drawable.pause else R.drawable.play
                        ),
                        contentDescription = if (isPlaying) stringResource(id = R.string.pause) else stringResource(id = R.string.play),
                        tint = Primary
                    )
                }
                // Skip Previous
                IconButton(onClick = {
                    currentStepIndex = (currentStepIndex - 1).coerceAtLeast(0)
                    isPlaying = false
                }) {
                    Icon(
                        painter = painterResource(id = R.drawable.skip_previous),
                        contentDescription = stringResource(id = R.string.previous),
                        tint = Primary
                    )
                }
                // Skip Next
                IconButton(onClick = {
                    currentStepIndex = (currentStepIndex + 1).coerceAtMost(steps.lastIndex)
                    isPlaying = false
                }) {
                    Icon(
                        painter = painterResource(id = R.drawable.skip_next),
                        contentDescription = stringResource(id = R.string.next),
                        tint = Primary
                    )
                }
                // Refresh (reset)
                IconButton(onClick = {
                    isPlaying = false
                    resetArray(arrayState, arraySize, maxNumber = 800)
                    steps.clear()
                    steps.addAll(generateBubbleSortSteps(arrayState))
                    currentStepIndex = 0
                }) {
                    Icon(
                        painter = painterResource(id = R.drawable.refresh),
                        contentDescription = stringResource(id = R.string.reset),
                        tint = Primary
                    )
                }
            }
        }
    }
}
