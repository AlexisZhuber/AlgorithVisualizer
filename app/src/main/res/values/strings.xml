<!-- File: strings.xml - Algorithm Visualizer Strings -->
<resources xml:space="preserve">

    <!-- ========================================================= -->
    <!-- GENERAL: Application Information                        -->
    <!-- ========================================================= -->
    <string name="app_name">Algorithm Visualizer</string>


    <!-- ========================================================= -->
    <!-- ALGORITHM EXPLANATIONS                                  -->
    <!-- Cada string contiene la explicación y un ejemplo en Kotlin -->
    <!-- ========================================================= -->

    <!-- Explanation for Bubble Sort (unchanged) -->
    <string name="explanation_text_bubble">
        <![CDATA[
What is Bubble Sort?

Bubble Sort is a simple sorting algorithm that works by repeatedly comparing
adjacent elements in a list and swapping them if they are in the wrong order.

Imagine you have a row of numbers and you want to sort them from smallest to largest.
Bubble Sort will look at the first two numbers, swap them if needed, then move on
to the next pair, and so on. With each pass, the largest unsorted number "bubbles"
up to its correct position.

Here is an example in Kotlin:\n\n

fun bubbleSort(arr: MutableList<Int>) {\n
\u00A0    for (i in 0 until arr.size) {\n
\u00A0\u00A0        for (j in 0 until arr.size - i - 1) {\n
\u00A0\u00A0\u00A0            if (arr[j] > arr[j + 1]) {\n
\u00A0\u00A0\u00A0\u00A0               val temp = arr[j]\n
\u00A0\u00A0\u00A0\u00A0               arr[j] = arr[j + 1]\n
\u00A0\u00A0\u00A0\u00A0               arr[j + 1] = temp\n
\u00A0\u00A0 \u00A0\u00A0           }\n
\u00A0\u00A0\u00A0        }\n
\u00A0\u00A0}\n
}\n\n

In this visualizer, each bar represents a number. The numbers are displayed on the bars,
and the two bars being compared are highlighted in a different color.

Enjoy learning and have fun with Bubble Sort!
        ]]>
    </string>

    <!-- NEW: Explanation for Selection Sort -->
    <string name="explanation_text_selection">
        <![CDATA[
What is Selection Sort?

Selection Sort is a straightforward algorithm that works by finding the smallest element
in the unsorted portion of the list and swapping it with the element at the beginning
of the unsorted portion.

Imagine you have a row of numbers. Selection Sort will scan the entire list to find
the smallest number, then swap it into the first position. Next, it moves the boundary
of the sorted portion one step to the right and repeats the process for the remaining
unsorted part, until the entire list is sorted.

Here is an example in Kotlin:\n\n

fun selectionSort(arr: MutableList<Int>) {\n
\u00A0    for (i in 0 until arr.size - 1) {\n
\u00A0\u00A0        var minIndex = i\n
\u00A0\u00A0        for (j in i+1 until arr.size) {\n
\u00A0\u00A0\u00A0            if (arr[j] < arr[minIndex]) {\n
\u00A0\u00A0\u00A0\u00A0               minIndex = j\n
\u00A0\u00A0\u00A0            }\n
\u00A0\u00A0        }\n
\u00A0\u00A0        // Swap the found minimum with the element at i\n
\u00A0\u00A0        val temp = arr[i]\n
\u00A0\u00A0        arr[i] = arr[minIndex]\n
\u00A0\u00A0        arr[minIndex] = temp\n
\u00A0    }\n
}\n\n

In this visualizer, each bar represents a number. The numbers are displayed on the bars,
and the two bars being compared are highlighted in a different color.

Enjoy learning and have fun with Selection Sort!
        ]]>
    </string>

    <!-- Explanation for BFS in Graphs -->
    <string name="explanation_text_bfs">
        <![CDATA[
What is a Graph?\n\n
A graph is a collection of nodes (or vertices) connected by edges. Graphs are used to model relationships between objects, such as social networks, transportation routes, or web pages.\n\n
What is Breadth-First Search (BFS)?\n\n
Breadth-First Search (BFS) is an algorithm used to traverse or search through a graph. Starting from a source node, BFS visits all the neighbors of that node first before moving on to the neighbors’ neighbors. This level-by-level approach is useful for finding the shortest path in an unweighted graph.\n\n
How Does BFS Work?\n\n
1. Start from a source node and mark it as visited.\n
2. Add the source node to a queue.\n
3. While the queue is not empty:\n
\u00A0\u00A0- Remove the node at the front of the queue.\n
\u00A0\u00A0- For each neighbor of this node:\n
\u00A0\u00A0\u00A0\u00A0If the neighbor has not been visited, mark it as visited, record its level (distance from the source), and add it to the queue.\n
4. Continue until all reachable nodes have been visited.\n\n
Example in Kotlin:\n\n
fun bfs(start: Int, adjacency: List<List<Int>>): List<Int> {\n
\u00A0\u00A0    val visited = MutableList(adjacency.size) { false }\n
\u00A0\u00A0    val level = MutableList(adjacency.size) { -1 }\n
\u00A0\u00A0    val queue = ArrayDeque<Int>()\n\n
\u00A0\u00A0    visited[start] = true\n
\u00A0\u00A0    level[start] = 0\n
\u00A0\u00A0    queue.add(start)\n\n
\u00A0\u00A0    while (queue.isNotEmpty()) {\n
\u00A0\u00A0\u00A0        val current = queue.removeFirst()\n
\u00A0\u00A0\u00A0        // Process each neighbor of current\n
\u00A0\u00A0\u00A0        for (neighbor in adjacency[current]) {\n
\u00A0\u00A0\u00A0\u00A0            if (!visited[neighbor]) {\n
\u00A0\u00A0\u00A0\u00A0\u00A0                visited[neighbor] = true\n
\u00A0\u00A0\u00A0\u00A0\u00A0                level[neighbor] = level[current] + 1\n
\u00A0\u00A0\u00A0\u00A0\u00A0                queue.add(neighbor)\n
\u00A0\u00A0\u00A0\u00A0            }\n
\u00A0\u00A0\u00A0        }\n
\u00A0\u00A0    }\n\n
\u00A0\u00A0    return level // Returns the distance from the start for each node\n
    }\n\n
What Will You See in This Visualizer?\n\n
In this visualizer, each node of the graph is represented as a circle arranged in a circular layout.\n
Edges between nodes are drawn as lines. The color of each node indicates its BFS status:\n
\u00A0\u00A0- Unvisited nodes appear in Gray.\n
\u00A0\u00A0- Visited nodes are shown in Blue.\n
\u00A0\u00A0- The current node being processed is highlighted in Red.\n\n
Watch how the algorithm expands level by level as you step through or play the animation.\n\n
Enjoy exploring graphs and learning how BFS works!
        ]]>
    </string>

    <string name="graph_info_bfs">
        Graph with %1$d nodes. Start node: %2$d.
    </string>
    <string name="results_title_bfs">BFS Search Results</string>
    <string name="results_description_bfs">
        The BFS search has completed the graph exploration. The visit order was: %1$s.
    </string>

    <!-- Explanation for Dijkstras Algorithm -->
    <string name="explanation_text_dijkstra">
    <![CDATA[
What is Dijkstras Algorithm?\n\n
Dijkstras Algorithm is a method to find the shortest path from a source node to every other node in a graph with non-negative edge weights. Imagine you have a map of cities connected by roads with different travel costs. This algorithm helps you determine the minimum distance required to travel to each city.\n\n
How Does It Work?\n\n
1. Initialize all distances to infinity (Int.MAX_VALUE), except for the source node, which is set to 0.\n
2. Mark all nodes as unvisited. Then, select the unvisited node with the smallest known distance. We call this the current node.\n
3. Mark the current node as visited. Next, look at all of its neighbors and update their distances if a shorter path is found via the current node.\n
4. Repeat this process until all nodes have been visited or no reachable nodes remain.\n\n
Example in Kotlin:\n\n
fun dijkstra(start: Int, adjacency: List<List<Pair<Int, Int>>>): List<Int> {\n
\u00A0\u00A0    val n = adjacency.size\n
\u00A0\u00A0    val dist = MutableList(n) { Int.MAX_VALUE }\n
\u00A0\u00A0    val visited = MutableList(n) { false }\n\n
\u00A0\u00A0    dist[start] = 0\n\n
\u00A0\u00A0    for (i in 0 until n) {\n
\u00A0\u00A0\u00A0        var u = -1\n
\u00A0\u00A0\u00A0        var minDist = Int.MAX_VALUE\n
\u00A0\u00A0\u00A0        // Find the unvisited node with the smallest distance\n
\u00A0\u00A0\u00A0        for (j in 0 until n) {\n
\u00A0\u00A0\u00A0\u00A0            if (!visited[j] && dist[j] < minDist) {\n
\u00A0\u00A0\u00A0\u00A0\u00A0                u = j\n
\u00A0\u00A0\u00A0\u00A0\u00A0                minDist = dist[j]\n
\u00A0\u00A0\u00A0\u00A0            }\n
\u00A0\u00A0\u00A0        }\n\n
\u00A0\u00A0\u00A0        // If u remains -1, there are no more reachable nodes\n
\u00A0\u00A0\u00A0        if (u == -1) break\n\n
\u00A0\u00A0\u00A0        // Mark u as visited\n
\u00A0\u00A0\u00A0        visited[u] = true\n\n
\u00A0\u00A0\u00A0        // Relax the distances of us neighbors\n
\u00A0\u00A0\u00A0        for ((v, weight) in adjacency[u]) {\n
\u00A0\u00A0\u00A0\u00A0            if (!visited[v]) {\n
\u00A0\u00A0\u00A0\u00A0\u00A0                val newDist = dist[u] + weight\n
\u00A0\u00A0\u00A0\u00A0\u00A0                if (newDist < dist[v]) {\n
\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0                    dist[v] = newDist\n
\u00A0\u00A0\u00A0\u00A0\u00A0                }\n
\u00A0\u00A0\u00A0\u00A0            }\n
\u00A0\u00A0\u00A0        }\n
\u00A0\u00A0    }\n\n
\u00A0\u00A0    return dist // Returns the shortest distance to each node\n
}\n\n
What Will You See in This Visualizer?\n\n
In this visualizer, each node in the graph is displayed as a circle with a number representing its distance from the source node. The edges (lines) show the weight or cost of each connection.\n
The currently processed node at each step will be highlighted in red, the nodes that have been permanently visited (fixed) will appear in blue, and unvisited nodes will appear in gray. As you step through or play the animation, you can watch how the algorithm updates distances and selects the next node with the minimum distance.\n
This step-by-step progression gives you a clear, visual understanding of how Dijkstras identifies the shortest paths in a graph with non-negative weights.\n\n
Enjoy learning and experimenting with Dijkstras Algorithm!
    ]]>
    </string>


    <!-- ========================================================= -->
    <!-- FINAL RESULTS CARD STRINGS                             -->
    <!-- Strings used for displaying the final results of Dijkstras Algorithm -->
    <!-- ========================================================= -->

    <string name="results_title">Detailed Results</string>
    <string name="results_description">
        <![CDATA[
Each circle displays two numbers:\n\n
• The number in the center is the node ID.\n
• The number below is the accumulated cost (i.e., the minimum distance from the origin).\n\n
The red line highlights the shortest route determined by Dijkstras algorithm.
    ]]>
    </string>
    <string name="table_header_node">Node</string>
    <string name="table_header_cost">Accumulated Cost</string>
    <string name="table_row_node">Node</string>
    <string name="results_footer">The red line shows the simplest route from the origin to the destination.</string>
    <string name="origin_label">ORIGIN</string>
    <string name="destination_label">DESTINATION</string>
    <string name="graph_info">
        <![CDATA[
Number of nodes: %1$d\n
Origin: %2$d\n
Destination: %3$d
]]>
    </string>


    <!-- ========================================================= -->
    <!-- ALGORITHM NAMES                                         -->
    <!-- ========================================================= -->
    <string name="bubble_sort">Bubble Sort</string>
    <string name="selection_sort">Selection Sort</string>
    <string name="BFS">BFS in Graphs</string>
    <string name="dijkstra">Dijkstras</string>
    <string name="quick_sort">Quick Sort</string>


    <!-- ========================================================= -->
    <!-- CONTROL BUTTON LABELS                                   -->
    <!-- ========================================================= -->
    <string name="play">Play</string>
    <string name="pause">Pause</string>
    <string name="previous">Previous</string>
    <string name="next">Next</string>
    <string name="reset">Reset</string>

</resources>
